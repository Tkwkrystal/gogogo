var userMongo = require('./users.dal'),
    userMongoV1 = require('./v1/users.dal'),
    license =  require('../../common/services/oxygenLicense.service'),
    roleReadService = require('../roles/roleRead.service'),
    userService = require('./users.service'),
    superUserService = require('./superUser.service'),
    userFactory = require('./users.factory'),
    hashService = require('../../common/security/hash.js'),
    isObject = require('lodash-compat/lang/isObject'),
    Q = require('q'),
    _ = require('underscore'),
    logger = require('../../common/logger').default('users-migration');

var DO_PROMISE = true;


function usersMigration(){

    this.migrateUserHashToNewHash = function () {
        var query = {hash:{$exists: true}};

        return userMongoV1.getUsers(query).then(function (users) {
            return Q.all(users.map(function (user) {
                if(user.hash && !isObject(user.hash)) {
                    if(user.encryptionSHA) {
                        user.hash = {"hash": user.hash,"type":hashService.HASH_TYPE_SHA256};
                        delete user.encryptionSHA;
                    } else {
                        user.hash = {"hash": user.hash,"type":hashService.HASH_TYPE_MD5};
                    }

                    return userMongoV1.updateUser(user._id, user);
                }
            }));
        });
    }

    this.verifySuperUser = function(){
        return superUserService.verifySuperUser();
    }

    // An oversight caused users which were auto-generated by our SSO mechanism to be created with a 'rules' attribute instead of a 'roles' attribute
    // this function finds them and fixes them (it's based on a previous function which did the same thing for users migrated from v.4.7)
    this.migrateRuleToRolesForSsoUsers = function(){
        var deferredObj = Q.defer();
        var query = {'rules.admin': true };
        var userItem = {rules:{},roles:{admin:true}};
        userMongo.updateWithQuery(query,userItem,function(err,results) {
            if (err){deferredObj.reject(err);}
            logger.info('admins migrated:' + results);

            var queryEveryoneElse  = {'rules': { $exists:true }, 'roles': {$exists: false} };
            var userItemConsumer = { $unset: {rules: ''},$set: {roles:{consumer:true}}};
            userMongo.updateWithQuery(queryEveryoneElse,userItemConsumer,function(err,results) {
                if (err){deferredObj.reject(err);}
                logger.info('Consumers migrated:' + results);
                    deferredObj.resolve(results);
//                var queryConsumer  = {'rules.canView': true };
//                var userItemConsumer = {rules:{},roles:{consumer:true}};
//                userMongo.updateWithQuery(queryConsumer,userItemConsumer,function(err,results) {
//                	if (err){deferredObj.reject(err);}
//                    console.log("Consumer migrated:" + results);
//                    deferredObj.resolve(results);
//                });
            });
        });
        return deferredObj.promise;
    }

    /**
     * Convert users roles from {admin : true, contributor : false, consumer :
     * true} to be a roleId that point to roles collection
     */
    this.convertRolesToNewFormat = function(){
        return roleReadService.getAllRoles()
        .then(function (allRoles){
            consumerRoleId = _.findWhere(allRoles, {name : 'consumer'})._id;
            contributorRoleId = _.findWhere(allRoles, {name : 'contributor'})._id;
            adminRoleId = _.findWhere(allRoles, {name : 'admin'})._id;
            superRoleId = _.findWhere(allRoles, {name : 'super'})._id;
            return userMongo.findAll(null, null, null, null, null, DO_PROMISE);
        }).then(function (users){
            var updateQueue = [];
            _.each(users, function(user){
                var role = user.roles;
                var roleId;
                // Check if the user role is in the old format
                roleId = consumerRoleId;
                if (role && _.isObject(role)){
                    if (role.super) {
                        roleId = superRoleId;
                    } else if (role.admin){
                        roleId = adminRoleId;
                    } else if (role.contributor){
                        roleId = contributorRoleId;
                    }
                }
                // If we run the migration in the future, it means
                // that will be users with the new role format
                // so we dont want to update them
                if (!user.roleId){
                    user.roleId = roleId;
                    updateQueue.push(userMongo.update(user._id, user));
                }
            });

            return Q.all(updateQueue);
        }).then(function (updateResult){
            logger.info(updateResult.length, ' users has been update to new role format');
        });
    }
}


usersMigration.instance = null;

usersMigration.getInstance = function(){
    if(this.instance === null){
        this.instance = new usersMigration();
    }
    return this.instance;
}


module.exports = usersMigration.getInstance();
